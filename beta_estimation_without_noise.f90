! Package : SI Toolkit
! Version : Beta / V1.0
! Date    : 24.03.2017   (UW Madison)

! Clebsch file must be generated by the code provided with this package.
! Otherwise it should be written in the exactly same format and the file should
! be a direct access file. 

! Function lm2n() :: m must be positive
! Function Smat() :: m values should be actual value not absolute values


use healpix_types
use omp_lib

integer,parameter :: LMAX = 2
integer,parameter :: llMAX = 1024

call generate_derivative(llMax,LMAX)

end program

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!           Generate Derivatives  (HM)              !!     
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine generate_derivative(llmax,LMAX) 
 
   use healpix_types
   use alm_tools
   use pix_tools
   use omp_lib

   integer :: i,j,k 
   integer :: llmax,LMAX
   integer :: nside,seed
   integer :: l2min,l2max
   integer :: m1max,m1min
   integer :: recno,r,h,l1,l2,m1,m2,MyLMAX

   real(dp) :: cleb,tempas

   real(dp), allocatable, dimension(:) :: Qr,Qi,Dr,Di,SMapr,SMapi        !
   real(dp), allocatable, dimension(:) :: RSMapr,RSMapi                  !
   real(dp), allocatable, dimension(:) :: Palmrdot,Palmidot              !  Map specific vaariables
   real(dp), allocatable, dimension(:) :: Qalmrdot,Qalmidot              !  
   real(dp), allocatable, dimension(:) :: Palmr,Malmr,Palmi,Malmi        !

   real(dp) :: Sum1

   real(dp) :: ALMll(0:LMAX,0:LMAX,0:llMAX,0:llMAX)                      !
   real(dp), allocatable, dimension(:,:,:,:) :: PALMlldot                !  BiPOSH coefficients
   real(dp) :: ALMlli(0:LMAX,0:LMAX,0:llMAX,0:llMAX)                     !    
   real(dp), allocatable, dimension(:,:,:,:) :: PALMllidot               !

   real(dp) :: epsilon1

   real(sp), allocatable, dimension(:,:) :: Map2
   real(dp), allocatable, dimension(:,:) :: dw8
   real(sp), allocatable, dimension(:) :: Map
   real(dp), dimension(2) :: z


   integer :: samplenumber,ll,lloopmax
   complex(spc), allocatable, dimension(:,:,:) :: alm
   integer :: repeat1,repl
   integer :: Npix
 
   real(dp) :: ProxyAl,fs(1:1050),beta(0:1),betai(0:1),betac(0:1),pbetadot(0:1)   !  Beta coeffifient specific variables
   real(dp) :: pbetaidot(0:1),pbetai(0:1),pbeta(0:1)                   !  

   real(dp) :: c_t1,c_t2,c_tf,c_ti

   real(sp), allocatable, dimension(:,:) :: cl,mcl
   real(dp),allocatable,dimension(:) :: Nl
   real(dp),allocatable,dimension(:) :: Clebs  
   character :: fileinput*500, input_map_path*1024, out_dir_path*1024
   character :: shape_factor_path*1024

   real :: tempx
   nside = 512

   allocate(Clebs(0:35000000))
   allocate(cl(0:llmax,1:3))
   allocate(mcl(0:llmax,1:3))
   allocate(Nl(0:llmax))

   allocate(alm(1:3, 0:llmax, 0:llmax))
   allocate(Qr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Qi(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Dr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Di(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Palmrdot(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Palmidot(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Qalmrdot(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Qalmidot(0:(llmax+1)*(llmax+2)/2-1))
   allocate(SMapr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(SMapi(0:(llmax+1)*(llmax+2)/2-1))
   allocate(RSMapr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(RSMapi(0:(llmax+1)*(llmax+2)/2-1))

   allocate(Palmr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Malmr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Palmi(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Malmi(0:(llmax+1)*(llmax+2)/2-1))

   allocate(Map2(0:12*nside*nside-1,1:3))
   allocate(Map(0:12*nside*nside-1))  
   allocate(dw8(1:2*nside, 1:3))

   allocate(PALMlldot(0:LMAX,0:LMAX,0:llMAX,0:llMAX))
   allocate(PALMllidot(0:LMAX,0:LMAX,0:llMAX,0:llMAX))

   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !!             Initiallize stepsize                    !!
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

print *, "Enter full path to input map"
read(*,*)input_map_path
write(*,*)"input_map_name = ", trim(adjustl(input_map_path))

print *, "Enter full path to shape factor file"
read(*,*)shape_factor_path
write(*,*)"shape_factor_path: ", trim(adjustl(shape_factor_path))
 
print *, "Enter path to directory to store output."
read(*,*)out_dir_path
write(*,*)"out_dir_path: ", trim(adjustl(out_dir_path))

   epsilon1 = 0.01
   Npix = 12*nside*nside

   !   Read the map     
   open(unit=141,file=input_map_path)
   do i=0,Npix-1
      read(141,*)Map(i)
   end do
   close(unit=141)
   write(*,*)'input_map_path :',input_map_path
   
   !  Read the fs file
   open(unit=1441,file=shape_factor_path)
   do i=0,llmax
      read(1441,*)k,fs(i)
      fs(i)= 0.01*fs(i)
   end do
   close(1441)
   write(*,*)'shape factor used :',shape_factor_path

   open(unit=1451,file='PlanckCl.dat')
   do i=2,llmax
     read(1451,*)temp,mcl(i,1),temp,temp,temp
   end do 

   dw8 = 1.0_dp
   z = (-1.d0,1.d0)
   Map2(:,1)=map

   call map2alm(nside, llmax, llmax, map2, alm, z, dw8)
   alm(1,0,0) = 50.0
   alm(1,1,0) = 50.0
   alm(1,1,1) = 50.0

   call alm2cl(llmax, llmax, alm, cl)

   open(unit=144,file='Clh.d') 
   do i=0,llmax
      ALMll(0,0,i,i) = cl(i,1) 
      write(144,*)cl(i,1)
      Nl(i) = 0.0001   ! Initiallize noise matrix
   end do
   close(unit=144) 

   open(1,file='/home/sdas33/DATA/FShabbir/clebsch/clebs.dat',access='direct',recl=64, action='read',status="OLD")
      do i=0,LMAX
        do k=0,llmax
          l1=k           ! k --> l1  
          l2min=l1
          IF (Abs(i-k).ge.k) l2min=Abs(k-i)
          l2max=llmax
          IF ((i+k).lt.llmax) l2max=(i+k)
          do h=l2min,l2max
            l2=h         ! h --> l2
            do j=0,i
              m1max = min(l1,l2-j)
              m1min = max(-l1,-l2-j)
              do r=1,int(m1max-m1min)+1 
                m1=int(m1min+float(r-1)) 
                call Sii(i,j,k,h,m1,llmax,recno)
                read(1,rec=recno)cleb
                Clebs(recno)=cleb  
              enddo 
            enddo
          enddo
        enddo
      enddo
   close(1)

   MyLMAX = 2

   open(unit=9169,file=trim(adjustl(out_dir_path))//'betaVal.d')

   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !!             Initiallize the masses                  !!
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   call initM(Malmr,Malmi,llmax,cl,Nl)

   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !!  Initiallize Data. Also initiallise alm to Data for faster convergence  !!
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   k = 0
   do i = 0,llmax
      do j = 0,i
         Qr(k)=real(alm(1,i,j))
         Qi(k)=aimag(alm(1,i,j))
         Dr(k) = Qr(k)
         Di(k) = Qi(k)
         k = k+1
      end do
   end do

   call calculateALM(Qr,Qi,LMAX,llmax,ALMll,ALMlli,Clebs)


   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !!        Initial Potential energy (EVEN BEFORE LOOP STARTS)          !! 
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   call srand(time())                   !! Starting random number generator

   lloopmax =(llmax+1)*(llmax+2)/2-1

   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !!              H. M. C. loop Begin                          !!
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   epsilon1 =  0.1 !025 !0.005
   theta = 1.35120719195966
   MyLMAX = 2

   do j=0,1

     beta(j) = 0.0
     betai(j) = 0.0
     betac(j)  = 0.0

     do l1=2,llmax-2
       beta(j)  = beta(j)  + (ALMll(1,j,l1,l1+1)*fs(l1))/(cl(l1,1)*cl(l1,1))
       betai(j) = betai(j) + (ALMlli(1,j,l1,l1+1)*fs(l1))/(cl(l1,1)*cl(l1,1))
       betac(j)  = betac(j)+ fs(l1)*fs(l1)/(cl(l1,1)*cl(l1,1))
     end do

     beta(j)=beta(j)/betac(j)
     betai(j)=betai(j)/betac(j)


     do l1=2,llmax-1
       ALMll(0,0,l1,l1) = mcl(l1,1)*2*3.14*sqrt(2.0*l1+1.0)*(-1)**l1/(l1*(l1+1.0))
       ALMll(1,j,l1,l1+1)   = beta(j)*fs(l1)
       ALMll(1,j,l1,l1-1)   = beta(j)*fs(l1)
       ALMlli(1,j,l1,l1+1)  = betai(j)*fs(l1)
       ALMlli(1,j,l1,l1-1)  = betai(j)*fs(l1)
     end do
   end do
   
   write(*,*)beta,betai

   call srand(seed)
   do samplenumber=0,5000                                             ! Number of samples                           

     call initPM(Palmr,Palmi,Malmr,Malmi,llmax,int(10000.0*rand()))   ! Initiallizing momentum 
     call initbeta(pbeta,int(10000.0*rand()))                         !   
     call initbeta(pbetai,int(10000.0*rand()))                        !

     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     !!      The next part is the Hamiltonion dynamics               !!
     !!      This part should be repeted                             !!     
     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

     repl=2+int(10.0*rand(seed))
     do repeat1 = 0,repl      !! Number of steps in a single Hamiltonion is taken as random to avoid resonance 


       !! Just for precosion A_LM should not be more then 25% of C_l                      
       !! `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` ``

         do i=1,MyLMax                                                                                      !
           do j=0,i                                                                                         !  
             do l1=2,llmax                                                                                  !
               l2min=l1                                                                                     ! 
               IF (Abs(i-l1).ge.l1) l2min=Abs(l1-i)                                                         !
               l2max=llmax                                                                                  !
               IF ((i+l1).lt.llmax) l2max=(i+l1)                                                            !
               do l2=l2min,l2max                                                                            !
                 if( abs(ALMll(i,j,l1,l2)) .gt. 0.25*sqrt(abs(ALMll(0,0,l1,l1)*ALMll(0,0,l2,l2)))) then     !
                   if(ALMll(i,j,l1,l2).ge.0) then                                                           !
                      flag = 1                                                                              !
                   else                                                                                     !
                      flag = -1                                                                             !
                   end if                                                                                   !
                   write(*,*) 'Err 1',i,j,l1,l2,ALMll(i,j,l1,l2)                                            !
                   ALMll(i,j,l1,l2) = 0.25*flag*sqrt(abs(ALMll(0,0,l1,l1)*ALMll(0,0,l2,l2)))                !
                 end if                                                                                     !
                 if( abs(ALMlli(i,j,l1,l2)) .gt. 0.25*sqrt(abs(ALMll(0,0,l1,l1)*ALMll(0,0,l2,l2)))) then    !
                   if(ALMlli(i,j,l1,l2).ge.0) then                                                          !
                      flag = 1                                                                              !
                   else                                                                                     !
                      flag = -1                                                                             !
                   end if
                   write(*,*)'Err 2',i,j,l1,l2,ALMll(i,j,l1,l2)
                   ALMlli(i,j,l1,l2) = 0.25*flag*sqrt(abs(ALMll(0,0,l1,l1)*ALMll(0,0,l2,l2)))
                 end if 
               end do
             end do
           end do
         end do

!$omp parallel do &
!$omp shared ( Qalmrdot, Palmr, Malmr, Qr, Qalmidot, Palmi, Malmi, Qi, epsilon1,theta) &
!$omp private ( i, l, m )
         do i=0,lloopmax

           Qalmrdot(i) = Palmr(i)/Malmr(i)
           Qalmidot(i) = Palmi(i)/Malmi(i)

           Qr(i) = Qr(i)  + Qalmrdot(i)*epsilon1*theta/2
           Qi(i) = Qi(i)  + Qalmidot(i)*epsilon1*theta/2

           call n2lm(i,l,m)
           if(m.eq.0) then
             Qi(i) = 0.0
           end if
         end do
!$omp end parallel do


         do j=0,1
           beta(j)  = beta(j)  + pbeta(j)*epsilon1*theta/2.0
           betai(j) = betai(j) + pbetai(j)*epsilon1*theta/2.0
         end do

        do l1=2,llmax-1
        do j =0,1
          ALMll(1,j,l1,l1+1)   = beta(j)*fs(l1)
          ALMll(1,j,l1,l1-1)   = beta(j)*fs(l1)
          ALMlli(1,j,l1,l1+1)  = betai(j)*fs(l1)
          ALMlli(1,j,l1,l1-1)  = betai(j)*fs(l1)
        end do 
        end do

      call gauss_seidel(ALMll,ALMlli,Qr,Qi,SMapr,SMapi,RSMapr,RSMapi,llmax,LMAX,Clebs)  

!$omp parallel do &
!$omp shared ( Palmr, Palmi, Palmrdot, Palmidot, epsilon1, theta) &
!$omp private ( i, l, m )
        do i=0,lloopmax
          call n2lm(i,l,m)
          if(m.ne.0) then 
            Palmrdot(i)  = - 2.0*(Dr(i) - Qr(i))/Nl(l) + 2.0*RSMapr(i) 
            Palmidot(i)  = - 2.0*(Di(i) - Qi(i))/Nl(l) + 2.0*RSmapi(i) 
          else 
            Palmrdot(i)  = - 1.0*(Dr(i) - Qr(i))/Nl(l) + 1.0*RSmapr(i) 
            Palmidot(i)  = 0.0
          end if
        end do
!$omp end parallel do

      call calculateALM(Smapr,Smapi,lmax,llmax,PALMlldot,PALMllidot,Clebs)
 
        do l1=2,llmax-1
          if(abs(ALMll(0,0,l1,l1)).lt.1.0d-20) ALMll(0,0,l1,l1) = 1.0d-20
          ProxyAl = ALMll(0,0,l1,l1)

          PALMlldot(0,0,l1,l1) = PALMlldot(0,0,l1,l1)/2.0
          PALMllidot(0,0,l1,l1) = PALMllidot(0,0,l1,l1)/2.0
          do j=0,1
             PALMlldot(1,j,l1,l1+1) = PALMlldot(1,j,l1,l1+1)/2.0
             PALMllidot(1,j,l1,l1+1) = PALMllidot(1,j,l1,l1+1)/2.0
          end do
        end do   

        do j=0,1
          pbetadot(j) = 0
          pbetaidot(j)= 0
        end do
 
        do l1=2,llmax-2              
          PALMlldot(0,0,l1,l1) = (2.0*l1+1.0)/ProxyAl/2.0 + PALMlldot(0,0,l1,l1)
          l2 = l1+1
          do j=0,1
            PALMlldot(1,j,l1,l1-1) = PALMlldot(1,j,l1,l1+1)
            PALMllidot(1,j,l1,l1-1) = PALMllidot(1,j,l1,l1+1)
  pbetadot(j) = pbetadot(j) + (-((-1.0)**j)*PALMlldot(1,j,l1,l1+1)+sqrt((2.0*l1+3.0)*(2.0*l1+1.0))*int((-1)**(l1+l2)) &
*ALMll(1,j,l1,l1+1)/ALMll(0,0,l1,l1)/ALMll(0,0,l2,l2)/2.0)*fs(l1)
  pbetaidot(j) = pbetaidot(j) + (-((-1.0)**j)*PALMllidot(1,j,l1,l1+1)+sqrt((2.0*l1+3.0)*(2.0*l1+1.0))*int((-1)**(l1+l2)) &
*ALMlli(1,j,l1,l1+1)/ALMll(0,0,l1,l1)/ALMll(0,0,l2,l2)/2.0)*fs(l1)
          end do
       end do

!$omp parallel do &
!$omp shared ( Palmr, Palmi, Palmrdot, Palmidot, Qi, epsilon1, theta) &
!$omp private ( i, l, m ) 
      do i=0,lloopmax
           Palmr(i) = Palmr(i) - Palmrdot(i)*epsilon1*theta
           Palmi(i) = Palmi(i) - Palmidot(i)*epsilon1*theta 
 
           call n2lm(i,l,m)
           if(m.eq.0) then
             Qi(i) = 0.0
           end if
      end do
!$omp end parallel do

      do j=0,1
         pbeta(j)  = pbeta(j)  - pbetadot(j)*epsilon1*theta
         pbetai(j) = pbetai(j) - pbetaidot(j)*epsilon1*theta
      end do

!$omp parallel do &
!$omp shared ( Qalmrdot, Palmr, Malmr, Qr, Qalmidot, Palmi, Malmi, Qi, epsilon1,theta) &
!$omp private ( i, l, m )

      do i=0,lloopmax
         Qalmrdot(i) = Palmr(i)/Malmr(i)
         Qalmidot(i) = Palmi(i)/Malmi(i)

         Qr(i) = Qr(i) + Qalmrdot(i)*epsilon1*(1.0-theta)/2.0
         Qi(i) = Qi(i) + Qalmidot(i)*epsilon1*(1.0-theta)/2.0

         call n2lm(i,l,m)

         if(m.eq.0) then
           Qi(i) = 0.0
         end if
      end do

!$omp end parallel do


      do j=0,1
         beta(j)  = beta(j)  + pbeta(j)*epsilon1*(1-theta)/2.0
         betai(j) = betai(j) + pbetai(j)*epsilon1*(1-theta)/2.0
      end do


      do l1=2,llmax-1
        do j=0,1
          ALMll(1,j,l1,l1+1)   = beta(j)*fs(l1)
          ALMll(1,j,l1,l1-1)   = beta(j)*fs(l1)
          ALMlli(1,j,l1,l1+1)  = betai(j)*fs(l1)
          ALMlli(1,j,l1,l1-1)  = betai(j)*fs(l1)
        end do
      end do


      call gauss_seidel(ALMll,ALMlli,Qr,Qi,SMapr,SMapi,RSMapr,RSMapi,llmax,LMAX,Clebs)

!$omp parallel do &
!$omp   shared ( Dr, Di, Qr, Qi, Nl, SMapi, SMapr, Palmrdot, Palmidot) &
!$omp   private ( i, l, m )
      do i=0,lloopmax
        call n2lm(i,l,m)
        if(m.ne.0) then
          Palmrdot(i)  = - 2.0*(Dr(i) - Qr(i))/Nl(l) + 2.0*RSMapr(i)
          Palmidot(i)  = - 2.0*(Di(i) - Qi(i))/Nl(l) + 2.0*RSmapi(i)
        else
          Palmrdot(i)  = - 1.0*(Dr(i) - Qr(i))/Nl(l) + RSmapr(i) 
          Palmidot(i)  = 0.0
        end if
      end do
!$omp end parallel do

      call calculateALM(Smapr,Smapi,lmax,llmax,PALMlldot,PALMllidot,Clebs)

      do l1=2,llmax-1
         if(abs(ALMll(0,0,l1,l1)).lt.1.0d-20) ALMll(0,0,l1,l1) = 1.0d-20
         ProxyAl = ALMll(0,0,l1,l1)

         PALMlldot(0,0,l1,l1) = PALMlldot(0,0,l1,l1)/2.0
         PALMllidot(0,0,l1,l1) = PALMllidot(0,0,l1,l1)/2.0
         do j=0,1
            PALMlldot(1,j,l1,l1+1) = PALMlldot(1,j,l1,l1+1)/2.0
            PALMllidot(1,j,l1,l1+1) = PALMllidot(1,j,l1,l1+1)/2.0
         end do
      end do

      do l1=2,llmax-1   
         PALMlldot(0,0,l1,l1) = (2.0*l1+1.0)/ProxyAl/2.0 + PALMlldot(0,0,l1,l1)
         do j=0,1
            PALMlldot(1,j,l1,l1+1) = PALMlldot(1,j,l1,l1-1)
            PALMllidot(1,j,l1,l1+1) = PALMllidot(1,j,l1,l1-1)
            l2 = l1+1
   pbetadot(j) = pbetadot(j) + (-((-1.0)**j)*PALMlldot(1,j,l1,l1-1)+sqrt((2.0*l1+1.0)*(2.0*l1+3.0))*int((-1)**(l1+l2)) &
*ALMll(1,j,l1,l1+1)/ALMll(0,0,l1,l1)/ALMll(0,0,l2,l2)/2.0)*fs(l1)
   pbetaidot(j)= pbetaidot(j)+ (-((-1.0)**j)*PALMllidot(1,j,l1,l1-1)+sqrt((2.0*l1+1.0)*(2.0*l1+3.0))*int((-1)**(l1+l2)) &
*ALMlli(1,j,l1,l1+1)/ALMll(0,0,l1,l1)/ALMll(0,0,l2,l2)/2.0)*fs(l1)
          end do
      end do


!$omp parallel do &
!$omp   shared ( Palmr, Palmi, Palmrdot, Palmidot, epsilon1, theta) &
!$omp   private ( i, l, m )
      do i=0,lloopmax

         Palmr(i) = Palmr(i) - Palmrdot(i)*epsilon1*(1-2*theta)
         Palmi(i) = Palmi(i) - Palmidot(i)*epsilon1*(1-2*theta)

         call n2lm(i,l,m)

         if(m.eq.0) then
           Qi(i) = 0.0
         end if
      end do
!$omp end parallel do


      do j=0,1
         pbeta(j)  = pbeta(j)  - pbetadot(j)*epsilon1*theta
         pbetai(j) = pbetai(j) - pbetaidot(j)*epsilon1*theta
      end do


!$omp parallel do &
!$omp   shared ( Qalmrdot, Palmr, Malmr, Qr, Qalmidot, Palmi, Malmi, Qi, epsilon1,theta) &
!$omp   private ( i, l, m )

      do i=0,lloopmax
         Qalmrdot(i) = Palmr(i)/Malmr(i)
         Qalmidot(i) = Palmi(i)/Malmi(i)

         Qr(i) = Qr(i) + Qalmrdot(i)*epsilon1*(1-theta)/2
         Qi(i) = Qi(i) + Qalmidot(i)*epsilon1*(1-theta)/2

         call n2lm(i,l,m)
         if(m.eq.0) then
            Qi(i) = 0.0
         end if
      end do

!$omp end parallel do

      do j=0,1
          beta(j)  = beta(j)  + pbeta(j)*epsilon1*(1-theta)/2.0
          betai(j) = betai(j) + pbetai(j)*epsilon1*(1-theta)/2.0
      end do


      do l1=2,llmax-1
        do j=0,1
          ALMll(1,j,l1,l1+1)   = beta(j)*fs(l1)
          ALMll(1,j,l1,l1-1)   = beta(j)*fs(l1)
          ALMlli(1,j,l1,l1+1)  = betai(j)*fs(l1)
          ALMlli(1,j,l1,l1-1)  = betai(j)*fs(l1)
        end do
      end do

      call gauss_seidel(ALMll,ALMlli,Qr,Qi,SMapr,SMapi,RSMapr,RSMapi,llmax,LMAX,Clebs) 

!$omp parallel do &
!$omp   shared ( Dr, Di, Qr, Qi, Nl, SMapi, SMapr, Palmrdot, Palmidot) &
!$omp   private ( i, l, m )
      do i=0,lloopmax
          call n2lm(i,l,m)
          if(m.ne.0) then
             Palmrdot(i)  =  - 2.0*(Dr(i) - Qr(i))/Nl(l) + 2.0*RSMapr(i) 
             Palmidot(i)  =  - 2.0*(Di(i) - Qi(i))/Nl(l) + 2.0*RSmapi(i)
          else
             Palmrdot(i)  =  - 1.0*(Dr(i) - Qr(i))/Nl(l) + RSmapr(i)
             Palmidot(i)  = 0.0
          end if
      end do
!$omp end parallel do

      call calculateALM(Smapr,Smapi,lmax,llmax,PALMlldot,PALMllidot,Clebs)

      do l1=2,llmax-1
          if(abs(ALMll(0,0,l1,l1)).lt.1.0d-20) ALMll(0,0,l1,l1) = 1.0d-20
          ProxyAl = ALMll(0,0,l1,l1)

          PALMlldot(0,0,l1,l1) = PALMlldot(0,0,l1,l1)/2.0
          PALMllidot(0,0,l1,l1) = PALMllidot(0,0,l1,l1)/2.0
          do j=0,1
             PALMlldot(1,j,l1,l1+1) = PALMlldot(1,j,l1,l1+1)/2.0
             PALMllidot(1,j,l1,l1+1) = PALMllidot(1,j,l1,l1+1)/2.0
          end do
      end do

      do l1=2,llmax-1         
         PALMlldot(0,0,l1,l1) = (2.0*l1+1.0)/ProxyAl/2.0 + PALMlldot(0,0,l1,l1)
         l2 = l1+1 
         do j=0,1
            PALMlldot(1,j,l1,l1+1) = PALMlldot(1,j,l1,l1-1)
            PALMllidot(1,j,l1,l1+1) = PALMllidot(1,j,l1,l1-1)
   pbetadot(j) = pbetadot(j) + (-((-1.0)**j)*PALMlldot(1,j,l1,l1-1)+sqrt((2.0*l1+1.0)*(2.0*l1+3.0))*int((-1)**(l1+l2)) &
*ALMll(1,j,l1,l1+1)/ALMll(0,0,l1,l1)/ALMll(0,0,l2,l2)/2.0)*fs(l1)
   pbetaidot(j) = pbetaidot(j) + (-((-1.0)**j)*PALMllidot(1,j,l1,l1-1)+sqrt((2.0*l1+1.0)*(2.0*l1+3.0))*int((-1)**(l1+l2)) &
*ALMlli(1,j,l1,l1+1)/ALMll(0,0,l1,l1)/ALMll(0,0,l2,l2)/2.0)*fs(l1)
         end do
      end do

!$omp parallel do &
!$omp   shared ( Palmr, Palmi, Palmrdot, Palmidot, epsilon1,theta) &
!$omp   private ( i, l, m )

      do i=0,lloopmax
         Palmr(i) = Palmr(i) - Palmrdot(i)*epsilon1*theta
         Palmi(i) = Palmi(i) - Palmidot(i)*epsilon1*theta
         call n2lm(i,l,m)
         if(m.eq.0) then
           Qi(i) = 0.0
         end if
      end do
!$omp end parallel do

      do j=0,1
         pbeta(j)  = pbeta(j)  - pbetadot(j)*epsilon1*theta
         pbetai(j) = pbetai(j) - pbetaidot(j)*epsilon1*theta
      end do

!$omp parallel do &
!$omp   shared ( Qalmrdot, Palmr, Malmr, Qalmidot, Palmi, Malmi ) &
!$omp   private ( i, l, m )

      do i=0,lloopmax
         Qalmrdot(i) = Palmr(i)/Malmr(i)
         Qalmidot(i) = Palmi(i)/Malmi(i)
      end do

!$omp end parallel do

!$omp parallel do &
!$omp   shared ( Qalmrdot, Qr, Qalmidot, Qi, epsilon1,theta) &
!$omp   private ( i, l, m )

      do i=0,lloopmax
         call n2lm(i,l,m)
         Qr(i) = Qr(i) + Qalmrdot(i)*epsilon1*theta/2.0
         Qi(i) = Qi(i) + Qalmidot(i)*epsilon1*theta/2.0

         if(m.eq.0) then
            Qi(i) = 0.0
         end if      
      end do

!$omp end parallel do


      do j=0,1
         beta(j)  = beta(j)  + pbeta(j)*epsilon1*(theta)/2.0
         betai(j) = betai(j) + pbetai(j)*epsilon1*(theta)/2.0
      end do


     betai(0) = 0.0                  ! betai(0) can not be nonzero 

      do l1=40,llmax
       if(abs(ALMll(0,0,l1,l1)) .lt. 0.001) then
           ALMll(0,0,l1,l1) = 0.001*ALMll(0,0,l1,l1)/abs(ALMll(0,0,l1,l1))
           write(*,*)'Error 3'
       end if
      end do

     end do

     write(*,*)repl,beta,betai
     write(9169,*)beta,betai

   end do

end subroutine generate_derivative


!!
!! Initiallize mass  for alm
!! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

subroutine initM(Malmr,Malmi,llmax,cl,Nl)

   use healpix_types

   integer :: llmax,i,l,m
   real(dp) :: Malmr(0:(llmax+1)*(llmax+2)/2-1)
   real(dp) :: Malmi(0:(llmax+1)*(llmax+2)/2-1)
   real(sp) :: cl(0:llmax,1:3)
   real(dp) :: Nl(0:llmax)  

   do i=0,(llmax+1)*(llmax+2)/2-1
      call n2lm(i,l,m)
      if((abs(cl(l,1)-Nl(l))).gt.1.0d-5) then 
        Malmr(i) = 1.0/(abs(cl(l,1)-Nl(l)))+1.0/Nl(l)
        Malmi(i) = 1.0/(abs(cl(l,1)-Nl(l)))+1.0/Nl(l)
      else
        Malmr(i) = 1.0/(1.0d-5)+1.0/Nl(l)
        Malmi(i) = 1.0/(1.0d-5)+1.0/Nl(l)
      end if
   end do
   return
end subroutine


!!
!! Initiallize momentum for alm
!! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

subroutine initPM(Palmr,Palmi,Malmr,Malmi,llmax,j)

   use healpix_types
   use rngmod

   type(planck_rng) :: rng_handle
   real(dp) :: gauss,time

   integer :: llmax,i,j,inttime

   real(dp) :: Palmr(0:(llmax+1)*(llmax+2)/2-1)
   real(dp) :: Palmi(0:(llmax+1)*(llmax+2)/2-1)
   real(dp) :: Malmr(0:(llmax+1)*(llmax+2)/2-1)
   real(dp) :: Malmi(0:(llmax+1)*(llmax+2)/2-1)

   call cpu_time(time)
   inttime = int(time)
   call rand_init(rng_handle,j,inttime)

   do i=0,(llmax+1)*(llmax+2)/2-1
      Palmr(i) = sqrt(Malmr(i))*rand_gauss(rng_handle)
      Palmi(i) = sqrt(Malmi(i))*rand_gauss(rng_handle)
   end do

end subroutine


!!
!! Initiallize momentum for beta Variables
!! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

subroutine initbeta(beta,ii)

    use healpix_types
    use rngmod

    type(planck_rng) :: rng_handle

    integer :: ii
    real(dp) :: beta(0:1)

   call cpu_time(time)
   inttime = int(time)
   call rand_init(rng_handle,ii,inttime)


   beta(0) = rand_gauss(rng_handle)
   beta(1) = rand_gauss(rng_handle)

end subroutine



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!          Gauss Scidel Method                      !!     
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine gauss_seidel(ALMll,ALMlli,bMap,bmapi,SMAP,SMAPi,RSMAP,RSMAPi,llmax,LMAX,Clebs) 

   use healpix_types
   use omp_lib

   integer :: i,j,Nmax,k
   integer :: il,im,jl,jm,recno
   integer :: iminMPI,imaxMPI,valperMPI
   integer :: myid,numprocs 
   integer :: endflag,MPItag
   integer :: flag
   integer :: lmin,locallmax
   integer :: localimmax,nthreads,iMaxThreads

   real(dp) :: test11,test11i
   real(dp) :: Sum1,Sum2,Smat,Smattot,Sum1i,Smati
   real(dp) :: bMap(0:(llmax+1)*(llmax+2)/2-1),SMAP(0:(llmax+1)*(llmax+2)/2-1)
   real(dp) :: bMapi(0:(llmax+1)*(llmax+2)/2-1),SMAPi(0:(llmax+1)*(llmax+2)/2-1)
   real(dp) :: RSMAP(0:(llmax+1)*(llmax+2)/2-1), RSMAPi(0:(llmax+1)*(llmax+2)/2-1)
   real(dp) :: SMAPold(0:(llmax+1)*(llmax+2)/2-1),SMAPiold(0:(llmax+1)*(llmax+2)/2-1)
   real(dp) :: ALMll(0:LMAX,0:LMAX,0:llMAX,0:llMAX)
   real(dp) :: ALMlli(0:LMAX,0:LMAX,0:llMAX,0:llMAX)
   real(dp) :: error,err(0:1000)
   real(dp) :: Clebs(0:35000000)

   flag = 0

   Nmax = (llmax+1)*(llmax+2)/2-1
   SMAPold = 0
   SMAPiold = 0


   iminMPI = 0 !myid*valperMPI
   imaxMPI = Nmax !(myid+1)*valperMPI-1
  
!$omp parallel do &
!$omp   shared ( bMap, ALMll, Clebs, Smap, bMapi, Smapi, llmax, iminMPI, imaxMPI ) &
!$omp   private ( i, il, im, recno, nthreads )

   do i=iminMPI,imaxMPI
     call n2lm(i,il,im)
     call Sii(0,0,il,il,im,llmax,recno)
     Smap(i) = bMap(i)/(ALMll(0,0,il,il)*Clebs(recno))
     Smapi(i) = bMapi(i)/(ALMll(0,0,il,il)*Clebs(recno))
   end do

!$omp end parallel do


!$omp parallel do &
!$omp shared ( iminMPI, imaxMPI, LMAX, llmax, ALMll, ALMlli, Clebs,bmap, &
!$omp bmapi, Smap, Smapi ) &
!$omp private ( i, Sum1, Sum1i, il, im, lmin, locallmax, jl, immin, &
!$omp localimmax, jm, j, SMat, SMati )

     do i=iminMPI,imaxMPI
       Sum1 = 0.0
       Sum1i= 0.0
       call n2lm(i,il,im)
       lmin = il - LMAX
       if(lmin<0) lmin = 0
       locallmax = il+LMAX
       if(locallmax.ge.llmax)locallmax = llmax-1
       do jl=lmin,locallmax
         immin =im-1       ! As for dopplar boost LMAX is just  LMAX = 1
         if(immin<-jl)immin = -jl
         localimmax = im+1   !As fir dopplar boost LMAX =1  
         if(localimmax.ge.llmax)localimmax = llmax-1
         do jm=immin,localimmax
          call lm2n(jl,abs(jm),j)
           if(i.ne.j) then
            call Smat1(ALMll,il,im,jl,jm,LMAX,llMAX,SMat,Clebs)
            call Smat1i(ALMlli,il,im,jl,jm,LMAX,llMAX,SMati,Clebs)
            if(im .eq. jm) Smati = 0.0
            Sum1 = Sum1 + bmap(j)*Smat - bmapi(j)*Smati
            Sum1i = Sum1i + bmap(j)*Smati + bmapi(j)*Smat
           end if
          end do
       end do

       call Smat1(ALMll,il,im,il,im,LMAX,llMAX,SMat,Clebs)

          Sum1  = Sum1/SMat**2
          Sum1i = Sum1i/SMat**2

       if(il.lt.40) then
          Sum1  = 0.0
          Sum1i = 0.0
       end if

       RSMap(i) = (SMap(i)-Sum1)
       RSMapi(i)= (SMapi(i)-Sum1i)

     end do

!$omp end parallel do  

   return
end subroutine gauss_seidel



subroutine Smat1M(ALMll,il,im,jl,jm,LMAX,llMAX,Smat,Clebs)

  use healpix_types
  integer :: il,im,jl,jm
  integer :: L,M,recno
  integer :: LMAX,llMAX
  real(dp) :: Sum1,Smat,cleb
  real(dp) :: ALMll(0:LMAX,0:LMAX,0:llMAX,0:llMAX)
  real(dp) :: Clebs(0:35000000)

  Sum1 =0.0

  do L=0,LMAX
    do M=0,L
       if((im-jm).ne.M) then
         cleb = 0.0
       else if(abs(il-jl).gt.L) then
         cleb = 0.0
       else if(L.gt.(il+jl)) then
         cleb = 0.0
       else
         call Sii(L,M,il,jl,im,llmax,recno)
         cleb = Clebs(recno)
         if((L.eq.0).and.(M.eq.0)) then
           Sum1 = Sum1 + ALMll(L,M,il,jl)*cleb*int((-1)**im)
         else
           Sum1 = Sum1 !+ ALMll(L,M,il,jl)*cleb*int((-1)**im)
         endif
       end if
    end do
  end do
  Smat = Sum1
  return

end subroutine Smat1M



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine Smat1(ALMll,il,im,jl,jm,LMAX,llMAX,Smat,Clebs)

  use healpix_types 
  integer :: il,im,jl,jm
  integer :: L,M,recno
  integer :: LMAX,llMAX
  real(dp) :: Sum1,Smat,cleb,clebi
  real(dp) :: ALMll(0:LMAX,0:LMAX,0:llMAX,0:llMAX)
  real(dp) :: Clebs(0:35000000)

  Sum1 =0.0

  do L=0,LMAX
       M= jm-im
       if(abs(il-jl).gt.L) then 
         cleb = 0.0
       else if(L.gt.(il+jl)) then
         cleb = 0.0
       else
         if(M.lt.0) then 
           call Sii(L,M,il,jl,-im,llmax,recno)
           cleb = int((-1)**(il+jl-L))*Clebs(recno)
         else
           call Sii(L,M,il,jl,-im,llmax,recno)
           cleb = Clebs(recno)
         end if

         if(L.eq.0) then
           Sum1 = Sum1 + ALMll(L,M,il,jl)*cleb*int((-1)**im)
         else
           Sum1 = Sum1 !+ ALMll(L,M,il,jl)*cleb*int((-1)**im)
         endif
       end if
  end do
  Smat = Sum1
  return

end subroutine Smat1

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine Smat1i(ALMll,il,im,jl,jm,LMAX,llMAX,Smat,Clebs) !,Clebsi)

  use healpix_types
  integer :: il,im,jl,jm
  integer :: L,M,recno
  integer :: LMAX,llMAX
  real(dp) :: Sum1,Smat,cleb,clebi
  real(dp) :: ALMll(0:LMAX,0:LMAX,0:llMAX,0:llMAX)
  real(dp) :: Clebs(0:35000000)
!  real(dp) :: Clebsi(0:35000000)

  Sum1 =0.0

  do L=1,LMAX
!    do M=1,L
!       if((im-jm).ne.M) then
!         cleb = 0.0
       M = jm-im
       if(abs(il-jl).gt.L) then
         cleb = 0.0
       else if(L.gt.(il+jl)) then
         cleb = 0.0
       else
!         call Sii(L,M,il,jl,-im,llmax,recno)
         if(M.gt.0) then
           call Sii(L,M,il,jl,-im,llmax,recno)
           cleb = Clebs(recno)
         else if(M.lt.0) then
           call Sii(L,M,il,jl,-im,llmax,recno)
           cleb = int((-1)**(il+jl-L))*Clebs(recno)
         else 
           cleb = 0.0
         end if
 
         Sum1 = Sum1 + ALMll(L,M,il,jl)*cleb*int((-1)**im)
!         if((L.eq.0).and.(M.eq.0)) then
!         Sum1 = Sum1 + ALMll(L,M,il,jl)*(cleb - clebi*int((-1)**m))*int((-1)**im)
!         else
!           Sum1 = Sum1 + ALMll(L,M,il,jl)*(cleb - clebi*int((-1)**m))*int((-1)**im)
!         endif
       end if
!    end do
  end do
  Smat = Sum1

  return

end subroutine Smat1i

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine n2lm(n,l,m)

   use healpix_types
   integer :: n,l,m
   real(dp) :: lt

   lt = (sqrt(8.0*n+1)-1.0)/2.0
   l = int(lt)
   m = n-l*(l+1)/2

  return

end subroutine

subroutine lm2n(l,m,n)
    
   integer :: n,l,m 

   n = l*(l+1)/2 + m

  return

end subroutine


!!
!! Biposh Calculation 
!! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

subroutine calculateALM(almr,almi,lmax,llmax,ALMll,ALMli,Clebs)

   use healpix_types
   integer :: il,im,jl,jm
   integer :: L,M,recno
   integer :: LMAX,llMAX
   integer :: m1min,m1max
   integer :: i,k,h,j,r
   integer :: l2min,l2max 

   real(dp) :: Clebs(0:35000000)
   real(dp) :: Sum1,Smat
   real(dp) :: ALMll(0:LMAX,0:LMAX,0:llMAX,0:llMAX)
   real(dp) :: ALMli(0:LMAX,0:LMAX,0:llMAX,0:llMAX)
   real(dp) :: almr(0:(llmax+1)*(llmax+2)/2-1)
   real(dp) :: almi(0:(llmax+1)*(llmax+2)/2-1)
   real(dp) :: cleb
   real(dp) :: almllr,almlli,norm
   real(dp),dimension(2) :: talmr,talmi


 
   do i=0,LMAX
     do k=0,llmax
       l1=k               ! k --> l1  

       l2min=l1
       IF (Abs(i-k).ge.k) l2min=Abs(k-i)
       l2max=llmax
       IF ((i+k).lt.llmax) l2max=(i+k)
       do h=l2min,l2max
         l2=h         ! h --> l2
         do j=0,i
           m1max = min(l1,l2-j)
           m1min = max(-l1,-l2-j)
           almllr = 0.0
           almlli = 0.0 

!$omp parallel do &
!$omp shared ( m1max,m1min,i,j,k,h,llmax,almr,almi ) &
!$omp private (r,m1,m2,i1,i2,recno,talmr,talmi,cleb ) &
!$omp reduction(+:almllr,almlli)
           do r=1,int(m1max-m1min)+1   
             m1=int(m1min+float(r-1))
             m2=j-m1                  
             call lm2n(k,abs(m1),i1)
             call lm2n(h,abs(m2),i2)
             call Sii(i,j,k,h,(m1),llmax,recno)
             cleb = Clebs(recno)

             if (m1.ge.0) then
               talmr(1)=almr(i1)               
               talmi(1)=almi(i1)               
             elseif (m1.lt.0) then
               talmr(1)= int((-1)**m1)*almr(i1)      
               talmi(1)= int((-1)**(m1+1))*almi(i1)  
             endif

             if (m2.ge.0) then
               talmr(2)=almr(i2)                  
               talmi(2)=almi(i2)                    
             elseif (m2.lt.0) then
               talmr(2)= int((-1)**m2)*almr(i2)     
               talmi(2)= int((-1)**(m2+1))*almi(i2)  
             endif

             almllr=almllr+(talmr(1)*talmr(2)-talmi(1)*talmi(2))*cleb
             almlli=almlli+(talmr(1)*talmi(2)+talmr(2)*talmi(1))*cleb

           end do ! Ends loop over r --> m1 & m2

!$omp end parallel do

           norm  = 1.0 
           
           almllr=almllr*norm
           almlli=almlli*norm
           ALMll(i,j,k,h) = almllr
           ALMli(i,j,k,h) = almlli
         end do
       end do  
     end do
   end do
end subroutine

!!
!!  Clebsch file hash function. (L,M,l1,l2,m1,m2)->Si 
!! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

subroutine Sii(L,M,l1,l2,m1,lm,Si)

   integer L,M,lm
   integer l1,l2,m1,m11
   integer Si

   Si =(L*(L+1)/2+M)*(2*L+1)*((lm+1)*(lm+1)-0)
   Si = Si + (l2-(l1-L))*((lm+1)*(lm+1)-0) + l1*l1+m1+l1
   Si = Si+1
   return

end subroutine 
