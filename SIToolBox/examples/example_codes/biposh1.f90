! Package : SI Toolkit
! Version : Beta / V1.0
! Date    : 01.04.2017   (UW Madison)
! Code    : Example

! Date    : 19.05.2017   (Fermilab, Things are working fine. Most probably its
! the final version)

! Clebsch file must be generated by the code provided with this package.
! Otherwise it should be written in the exactly same format and the file should
! be a direct access file. 

! Function lm2n() :: m must be positive
! Function Smat() :: m values should be actual value not absolute values

use healpix_types
use omp_lib

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Function lm2n() :: m must be positive
!! Function Smat() :: m values should be actual value not absolute values
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 

integer,parameter :: LMAX = 2
integer,parameter :: llMAX = 1024
integer,parameter :: clbllMAX = 1024
integer,parameter :: clbLMAX = 2

integer :: i,l,m 

l=20
m=14
call lm2n(l,m,i)

write(*,*) i
!call generate_derivative(llMax,LMAX,clbllMAX,clbLMAX)

end program


subroutine generate_derivative(llmax,LMAX,clbllMAX,clbLMAX)
 
   use healpix_types
   use alm_tools
   use pix_tools
   use omp_lib

   integer :: i,j,k,kk,leapfrogloop     ! Variables used in loops etc

   integer :: llmain,llmax,LMAX         ! l_max (1024) and L_max (2)   of A^{L,M}_{l,l+d}
   integer :: nside                     ! Map Nside

   integer :: l2min,l2max               ! l2 can Vary within l-L to l+L in A^{L,M}_{l1,l2}
   integer :: m1max,m1min               ! Range of values that M can take
   integer :: recno,r,h,l1,l2,m1  


   integer :: clbllMAX,clbLMAX
   real(dp) :: cleb

   real(dp), allocatable, dimension(:) :: Qr,Qi,Dr,Di,SMapr,SMapi,bMap  ! Variables for updating Map alm's  
   real(dp), allocatable, dimension(:) :: RMapr,RMapi
   real(dp), allocatable, dimension(:) :: Palmrdot,Palmidot             !
   real(dp), allocatable, dimension(:) :: Qalmrdot,Qalmidot             !
   real(dp), allocatable, dimension(:) :: Palmr,Malmr,Palmi,Malmi       !

   real(dp) :: ALMll(0:LMAX,0:LMAX,0:llMAX,0:llMAX)                     !
   real(dp), allocatable, dimension(:,:,:,:) :: PALMlldot,QALMlldot     !
   real(dp), allocatable, dimension(:,:,:,:) :: PALMll,MALMll           ! Variables for updating ALMll
                                                                        !
   real(dp) :: ALMlli(0:LMAX,0:LMAX,0:llMAX,0:llMAX)                    !
   real(dp), allocatable, dimension(:,:,:,:) :: PALMllidot,QALMllidot   !
   real(dp), allocatable, dimension(:,:,:,:) :: PALMlli,MALMlli         !

   real(dp) :: epsilon1
   real(sp), allocatable, dimension(:,:) :: Map2
   real(dp), allocatable, dimension(:,:) :: dw8
   real(sp), allocatable, dimension(:) :: Map
   real(sp), allocatable, dimension(:) :: NoiseMap
   real(dp), dimension(2) :: z

   integer :: samplenumber,ll,lloopmax
   complex(spc), allocatable, dimension(:,:,:) :: alm, dfalm
   integer :: repeat1,repl
   integer :: Npix

   real(dp) :: ProxyAl

   real(sp), allocatable, dimension(:,:) :: cl
   real(dp),allocatable,dimension(:,:) :: Clo
   real(dp),allocatable,dimension(:) :: Nl
   real(dp),allocatable,dimension(:) :: Clebs 
   character :: fileinput*500,filename*100,filenamei*100,noisefileinput*100
   character(2) :: ci,cj,cl1

   real(dp) :: IALMll(1:10),timestart,timeend,noipix
   real(DP), dimension(:,:), allocatable :: plm 
   real(dp), allocatable, dimension(:) :: dfQr,dfQi

   nside = 512
 
   !!
   !! Allocating the arrrays
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
 
   allocate(Clebs(0:35000000))
   allocate(cl(0:llmax,1:3))
   allocate(Clo(0:llmax,50))
   allocate(Nl(0:llmax))
   allocate(alm(1:3, 0:llmax, 0:llmax))
   allocate(dfalm(1:3, 0:llmax, 0:llmax))
   allocate(Qr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Qi(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Dr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Di(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Palmrdot(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Palmidot(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Qalmrdot(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Qalmidot(0:(llmax+1)*(llmax+2)/2-1))
   allocate(bMap(0:(llmax+1)*(llmax+2)/2-1))
   allocate(SMapr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(SMapi(0:(llmax+1)*(llmax+2)/2-1))
   allocate(RMapr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(RMapi(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Palmr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Malmr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Palmi(0:(llmax+1)*(llmax+2)/2-1))
   allocate(Malmi(0:(llmax+1)*(llmax+2)/2-1))
   allocate(QALMlldot(0:LMAX,0:LMAX,0:llMAX,0:llMAX))
   allocate(PALMll(0:LMAX,0:LMAX,0:llMAX,0:llMAX))
   allocate(MALMll(0:LMAX,0:LMAX,0:llMAX,0:llMAX))
   allocate(Map2(0:12*nside*nside-1,1:3))
   allocate(Map(0:12*nside*nside-1))  
   allocate(NoiseMap(0:12*nside*nside-1))
   allocate(dw8(1:2*nside, 1:3))
   allocate(QALMllidot(0:LMAX,0:LMAX,0:llMAX,0:llMAX))
   allocate(PALMlli(0:LMAX,0:LMAX,0:llMAX,0:llMAX))
   allocate(MALMlli(0:LMAX,0:LMAX,0:llMAX,0:llMAX))
   allocate(PALMlldot(0:LMAX,0:LMAX,0:llMAX,0:llMAX))
   allocate(PALMllidot(0:LMAX,0:LMAX,0:llMAX,0:llMAX))
   allocate(dfQr(0:(llmax+1)*(llmax+2)/2-1))
   allocate(dfQi(0:(llmax+1)*(llmax+2)/2-1))

!   allocate(plm(0:nside*(llmax+1)*(2*llmax-llmax+2)-1,1:3)) 

   Npix = 12*nside*nside

   !!
   !!   Read the map file
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   fileinput = "data1/map97xdipole03.d"
   noisefileinput = "data1/Namap.d"
   open(unit=141,file=fileinput)
   open(unit=144,file=noisefileinput)

   do i=0,Npix-1
     read(141,*)Map(i)
     read(144,*)NoiseMap(i) 
   end do
   close(unit=141)
   close(unit=144)

   dw8 = 1.0_dp
   z = (-1.d0,1.d0)
   Map2(:,1)=map

   call map2alm(nside, llmax, llmax, map2, alm, z, dw8)
   alm(1,0,0) = 50.0         !
   alm(1,1,0) = 50.0         !   Initiallizing some random variables at a_00, a_10 and a_11 
   alm(1,1,1) = 50.0         !

   call alm2cl(llmax, llmax, alm, cl)
 
   open(unit=144,file='Clh.d') 
   do i=0,llmax
      ALMll(0,0,i,i) = cl(i,1)   !
      write(144,*)cl(i,1)        !
      Nl(i) = 0.0036             ! Initiallize noise matrix
   end do                        !  
   close(unit=144) 

   write(*,*)'Test.. 2'

   open(1,file='/home/sdas33/DATA/Final_beta_estimation/clebsch/clebs.dat',access='direct',recl=64, action='read',status="OLD")
   do i=0,LMAX
     do k=0,llmax
       l1=k           ! k --> l1  
       l2min=l1
       IF (Abs(i-k).ge.k) l2min=Abs(k-i)
       l2max=llmax
       IF ((i+k).lt.llmax) l2max=(i+k)
       do h=l2min,l2max
         l2=h         ! h --> l2
         do j=0,i
           m1max = min(l1,l2-j)
           m1min = max(-l1,-l2-j)
           do r=1,int(m1max-m1min)+1 
             m1=int(m1min+float(r-1)) 
             call Sii(i,j,k,h,m1,llmax,recno)
             read(1,rec=recno)cleb
             Clebs(recno)=cleb  
           enddo 
         enddo
       enddo
     enddo
   enddo
   close(1)
   
MyLMax = 2
   l1 =0
   do i=0,MyLMax
     do j=0,i
       do kk=0,i
         l1 = l1+1
         write(ci,"(I1)")i 
         write(cj,"(I1)")j
         write(cl1,"(I1)")kk
         filename  = 'BIPOSH/A_'//trim(ci)//trim(cj)//'_ll'//trim(cl1)//'.d'
         filenamei = 'BIPOSH/AI_'//trim(ci)//trim(cj)//'_ll'//trim(cl1)//'.d'
         write(*,*)filename,filenamei
         open(unit=8154+l1,file=filename)
         open(unit=9168+l1,file=filenamei)
       end do
     end do
   end do


   write(*,*)'Test .. 3'

   !!
   !!  Initiallize Data. Also initiallise alm to Data for faster convergence  
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   k = 0
   do i = 0,llmax
      do j = 0,i
         Qr(k)=real(alm(1,i,j))
         Qi(k)=aimag(alm(1,i,j))
         k = k+1
      end do
   end do

   write(*,*)'Test .. 3a'
   call calculateALM(Qr,Qi,LMAX,llmax,ALMll,ALMlli,Clebs)



      l1 =0
      do i=0,MyLMax
        do j=0,i
          do kk=0,i
             do k=0,llmax-3
               Clo(k,1) = ALMll(i,j,k,k+kk)
               Clo(k,2) = ALMlli(i,j,k,k+kk)
             end do
             l1 = l1+1
             write(8154+l1,*)Clo(:,1)
             write(9168+l1,*)Clo(:,2)
          end do
        end do
      end do

   call cpu_time(timeend)


   l1 =0
   do i=0,MyLMax
     do j=0,i
       do kk=0,i
          l1 = l1+1
          close(unit=8154+l1)
          close(unit=9168+l1)
          write(*,*)8154+l1,9168+l1
       end do
     end do
   end do



end subroutine generate_derivative

